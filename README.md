# 勉強したことをまとめていくよ
## 参考
[プログラミング言語Rust](https://doc.rust-jp.rs/the-rust-programming-language-ja/1.6/book/README.html)
# 1章 はじめる
## 知ったこと
- ! がついているとrustではマクロ扱いとなる
    - ついていなければ関数
    - マクロと関数の違いについては不明
- Cargoとはrustのビルドシステムでもありパッケージマネージャでもある
- Cargoはソースファイルをsrcディレクトリに存在することを要求する (!)
- Cargo.toml(Cは大文字)にCargoの設定を記述する
    - TOML: Tom's Obvious, Minimal Language
    - Cargoの設定フォーマットとして使われる
- `cargo build` でプロジェクトをビルドし、`cargo run`でプロジェクトを実行する
- `cargo run` では変更点の差分のみをコンパイルして実行してくれる
    - Makefileみたいな
- `cargo new`ってやるとtomlファイルとsrc配下にソースファイルが配置されたプロジェクトを生成してくれる
# 2.1章 数当てゲーム
- Rustが自動的にデフォルトで読み込むものはプレリュードと呼ばれ、それ以外はuseしないといけない
    - 標準入出力とやり取りするインターフェースが必要なら`use std::io;` する必要がある
    - プレリュード: おしゃれ。
```rust
let foo = bar;
```
- fooという束縛を作り、それをbarに束縛する、ということを表現している
    - 他の多くの言語では「変数」と呼ばれるもの。Rustでは束縛変数という
- Rustではletで宣言した束縛はデフォルトでイミュータブル。
    - ミュータブルな束縛を定義するためにmutを使う ( Ex. let mut foo = bar )

```rust
String::new()
```
- String型のインスタンスを生成しているわけではない
- ::new()は特定の型の「関連関数」(ここはよくわかってない)
    - スタティックメソッド、なんて名前で呼ばれているらしい
```rust
io::stdin().read_line(&mut guess).expect("hoge");
```
- io::stdin()は標準入出力をハンドルする
- guessという参照もデフォルトではイミュータブルなので、&mutをつけてミュータブルとして参照している
    - read_lineで取得したユーザの入力文字列を取得し、guessに代入するためにはミュータブルである必要がある

```rust
println!("hoge {}", hoge);
```
- {}はプレースホルダ
    - 複数の変数を入れたいなら「{}」も複数になる
    
 - Rustコードのパッケージは「クレート」と呼ばれる
    - Cargoプロジェクトで管理をしているなら、Cargo.tomlの[dependency]欄にクレートを記述することで依存関係を考慮してパッケージのダウンロードをしてくれる
    
- クレートはファイル内でextern use として指定することでインクルードする
- インクルードしたメソッドは、トレイトと呼ばれる空間で定義されているので、トレイトをスコープ内に取り込む必要がある ( Ex. rand::Rng)

- 値の大小を比較するときにはOrderingを使う
    - OrderingはenumでLess, Equal, Greaterという3つのバリアントを保持する

- Rustは型推論を持っているため、束縛される対象がString::new()とあれば、コンパイラはString型である、と理解をしてくれる
    - 数値に関しては、i32やu32,f64など、様々な型が用意されている
    - 指定がなければRustはデフォルトでi32として解釈する
    - 数値と文字列を単に比較しようとするとコンパイラはエラーを吐く
 
 - Rustでは同じ変数を再定義することができる( シャドーイング )
    - 型の変換時などに用いれられる
    
- matchがif文のような役割を果たしている
    - 返り値のenumに対して等しいか、大きいか小さいかなどを判定して、それに対するアクションを定義している

#2.2 食事する哲学者
- `struct`で構造体を定義する
    - メンバ名と型を宣言する
    - String型と&str型の違いは不明
- implブロックで構造体に関する定義を与える
```rust
impl Philosopher {
    fn new(name: &str) -> Philosopher {
        Philosopher {
            name: name.to_string(),
        }
    }
}
```
なら、Philospherに対してnewという"関連関数"を定義する
newではPhilosopherのインスタンスを返す
- rubyと同様、最後に評価した値が返り値となる
- new()という名前に縛りはないが、構造体からインスタンスを生成する際に慣例的に用いられる事が多い
- 可変長配列にはVec<T>を用いる
- Rustではメソッドは明示的なselfパラメータを取る
    - selfパラメータを取らないものは関連関数 ( 上のnewメソッドは関連関数 )
- Mutex: 並行処理を制御するための機構
    - 同時アクセスできるスレッドを単一にする
    - 今回の例だと各フォークにアクセスできるのは一人のみのためMutexを用いる
- Arc = アトミック参照カウント
    - 各スレッドからリソースを共有するために必要となる
    - 共有するときは参照カウントを増やし、各スレッドの終了時にはカウントを減らす　
    
# 2.3 Rust Inside Other Languages
- 高級言語の実行速度の遅さを補うためによくCで書いた実装を他の言語から呼び出して利用することがある
    - この技術はForeign Function Interface (FFI) と呼ばれる
## The Problem
- オブジェクト指向なプログラミング言語はGCを利用している
    - それで最適化されることもあるが、静的にメモリをアロケートしたい場合がある
- 多くの言語はGIL(Global Interpreter Lock) を持っている
    - これは並行処理に制限を与えている
## FFI
- fn の前に pub とつければモジュールの外から呼び出しが可能になる
- extern はCから呼び出す際に必要な枕詞になる
    
# 3-1 変数と可変性
- constキーワードで定数を宣言すれば、mutキーワードが使えず常に不変な値を持つ
    - 定数の命名規則は、全てが大文字でアンダースコアで単語区切りにする
- let で繰り返し宣言することをシャドーイング(前に宣言した変数を覆い隠している) という
```rust
let x = 5;
let x = 6; //これは許容される
x = 7 //これは許容されない
let x = "hoge" //再宣言なので違う型でもok( mut キーワードだとこれはできない )
```
# 3-2 データ型
## スカラー型
### 整数型
- i8なら符号付き8bit整数型
- u8なら符号なし8bit整数型
    - 16, 32, 64まで
- isize, usizeはプログラムが動作するコンピュータアーキテクチャに依存する
### 浮動小数点型
- f32 or f64
### 文字型
- RustではUnicodeに対応している
### 複合型
### タプル
```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
let (x , y, z) = tup; // x=500, y=6.4, z=1 が代入される
// tup.0, tup.1, tup.2 としても参照可
```
- パターンマッチングで抽出できるのが特徴
### 配列型
- Rustでは配列の大きさを返ることができない
    - 可変長配列はベクタで扱う
    
# 3-3 関数
- エントリポイントはmain関数
- 関数本体は文と式を含む
    - 文: 値を返さない命令
    - 式: 結果値に評価される命令
- `let x = 6;` は文
- 文を代入することはできない
    - `x = y = 6` はできないということ
- 文末にセミコロンをつけると、Rustコンパイラは文として扱うため、値を返さなくなるので注意
## 返り値
```rust
fn one() -> i32 { 1 }
```
- `-> 型` で返り値の型を明示的に宣言する
    - return も使えるが、多くの場合最後の式を暗黙的にreturnする形で記述されることが多い
    - 関数は式なので、セミコロンは付かない
# 3-4 コメント
特に書くことなし

#3-5 制御フロー
- ifの条件式としてboolのみが期待されている
- ifは式なのでletの右辺に持ってくることができる
### 繰り返し
- loop, for, whileがある
- loopは無限ループ
    - breakキーワードでループから抜けることができる
- whileはとく言うことなし
- forもiterを使うくらいは言うことなし

# 4-1 所有権とは
- Rustでは値がスタックに載るかヒープに載るかで、異なった影響を及ぼす場合がある
- スタックはLIFOの特徴があり、データの取り出しが高速だが、固定のメモリセグメントをアロケートしなければならない
- 動的にメモリの値が変わる値についてはヒープに確保される
- ヒープへのデータアクセスはスタックと比較して低速
- Rustの所有権はこのヒープに載っているデータを管理するための仕組み
## 所有権規則
- Rustの各値は所有者と呼ばれる変数と対応関係にある
- どんなときも所有者はひとり
- 所有者がスコープから外れると、値は破棄される
## String型
- 文字列をハードコードした「文字列リテラル」は静的な値なのでスタックで管理される
- 文字列を動的な値として処理したい場合がString型の文字列を定義する
    - メモリを動的に取れる、つまり可変であるということ
## メモリの確保
- GCは使用されていないメモリ領域を検知して片付ける
- GCがないならallocate -> freeをプログラマが制御してやらないといけない
- RustではGCがない代わりにメモリを所有している変数がスコープを抜けたタイミングでOSにメモリを返している
    - dropという関数が暗黙的に呼ばれている
## ムーブ
```rust
let x = 5;
let y = 5;
```
- 5を変数xに束縛したのち、その値をコピーしてyにも束縛している
```rust
let s1 = String::from("hello");
let s2 = s1;
println!("{}", s1); // これはコンパイルエラーを吐く
```
- s2はs1が束縛している文字列のポインタをコピーしている
    - ポインタ情報はスタックで管理されている
    - 実データはヒープに載っている
    - ヒープ上のデータがコピーされているわけではない
- s2とs1が同じメモリ領域を参照するという状況は問題がある
    - s1とs2がスコープを抜けたタイミングでdrop関数によって同じメモリ領域が2回freeされる
    - Rustコンパイラはs2のポインタをコピーしたタイミングでs1への参照を無効化する
- Rustではこの現象をムーブという
    - コピー元のデータにアクセスできなくなるshallow copy みたいな
- ヒープ上のデータもコピーしたい場合はcloneメソッドを使う
    - deep copy
    - これは本当に`コピー`なのでコピー元の変数にも参照することができる
- 整数などの固定長のデータはcloneメソッドがなくともデータそのものもコピーしている
    - スタック上に保持されているためデータのコピーも高速に動作する

# 4-2 参照と借用
- `&`を付け加えて参照することでもとの値を参照する参照を生成できる
    - 所有権を保持するわけではないのでdropされない
- 関数の引数に参照を取ることを借用と呼ぶ
    - 借用したものを変更することはできない
- `&mut`として可変な参照として渡せば参照する側からも変更が可能となる
    - あるスコープの中で可変な参照は一つしか持つことができない
    - 一方がある一方の参照元のデータが変わることをトレースできない
- 不変な参照をしている間は、可変な参照をすることができない
    - 不変参照をしている変数は値が変わることを予想していないから
- ダングリングポインタを防ぐ仕組みがRustコンパイラに備わっている
    - ポインタが参照している領域をfreeしようとするとエラーを吐く
    
# 4-3 スライス
- スライスとはデータ列の一部分だけを借用する仕組みを指す
- 文字列スライスを意味する型は&strと書かれる
- 文字列リテラルはバイナリの特定の位置のスライスを返す&str型
    - 関数の引数の型として`&str`を指定すれば、String型も文字列リテラルも両方扱えるようになる

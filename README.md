# 勉強したことをまとめていくよ
## 参考
[プログラミング言語Rust](https://doc.rust-jp.rs/the-rust-programming-language-ja/1.6/book/README.html)
# 1章 はじめる
## 知ったこと
- ! がついているとrustではマクロ扱いとなる
    - ついていなければ関数
    - マクロと関数の違いについては不明
- Cargoとはrustのビルドシステムでもありパッケージマネージャでもある
- Cargoはソースファイルをsrcディレクトリに存在することを要求する (!)
- Cargo.toml(Cは大文字)にCargoの設定を記述する
    - TOML: Tom's Obvious, Minimal Language
    - Cargoの設定フォーマットとして使われる
- `cargo build` でプロジェクトをビルドし、`cargo run`でプロジェクトを実行する
- `cargo run` では変更点の差分のみをコンパイルして実行してくれる
    - Makefileみたいな
- `cargo new`ってやるとtomlファイルとsrc配下にソースファイルが配置されたプロジェクトを生成してくれる
# 2.1章 数当てゲーム
- Rustが自動的にデフォルトで読み込むものはプレリュードと呼ばれ、それ以外はuseしないといけない
    - 標準入出力とやり取りするインターフェースが必要なら`use std::io;` する必要がある
    - プレリュード: おしゃれ。
```rust
let foo = bar;
```
- fooという束縛を作り、それをbarに束縛する、ということを表現している
    - 他の多くの言語では「変数」と呼ばれるもの。Rustでは束縛変数という
- Rustではletで宣言した束縛はデフォルトでイミュータブル。
    - ミュータブルな束縛を定義するためにmutを使う ( Ex. let mut foo = bar )

```rust
String::new()
```
- String型のインスタンスを生成しているわけではない
- ::new()は特定の型の「関連関数」(ここはよくわかってない)
    - スタティックメソッド、なんて名前で呼ばれているらしい
```rust
io::stdin().read_line(&mut guess).expect("hoge");
```
- io::stdin()は標準入出力をハンドルする
- guessという参照もデフォルトではイミュータブルなので、&mutをつけてミュータブルとして参照している
    - read_lineで取得したユーザの入力文字列を取得し、guessに代入するためにはミュータブルである必要がある

```rust
println!("hoge {}", hoge);
```
- {}はプレースホルダ
    - 複数の変数を入れたいなら「{}」も複数になる
    
 - Rustコードのパッケージは「クレート」と呼ばれる
    - Cargoプロジェクトで管理をしているなら、Cargo.tomlの[dependency]欄にクレートを記述することで依存関係を考慮してパッケージのダウンロードをしてくれる
    
- クレートはファイル内でextern use として指定することでインクルードする
- インクルードしたメソッドは、トレイトと呼ばれる空間で定義されているので、トレイトをスコープ内に取り込む必要がある ( Ex. rand::Rng)

- 値の大小を比較するときにはOrderingを使う
    - OrderingはenumでLess, Equal, Greaterという3つのバリアントを保持する

- Rustは型推論を持っているため、束縛される対象がString::new()とあれば、コンパイラはString型である、と理解をしてくれる
    - 数値に関しては、i32やu32,f64など、様々な型が用意されている
    - 指定がなければRustはデフォルトでi32として解釈する
    - 数値と文字列を単に比較しようとするとコンパイラはエラーを吐く
 
 - Rustでは同じ変数を再定義することができる( シャドーイング )
    - 型の変換時などに用いれられる
    
- matchがif文のような役割を果たしている
    - 返り値のenumに対して等しいか、大きいか小さいかなどを判定して、それに対するアクションを定義している

#2.2 食事する哲学者
- `struct`で構造体を定義する
    - メンバ名と型を宣言する
    - String型と&str型の違いは不明
- implブロックで構造体に関する定義を与える
```rust
impl Philosopher {
    fn new(name: &str) -> Philosopher {
        Philosopher {
            name: name.to_string(),
        }
    }
}
```
なら、Philospherに対してnewという"関連関数"を定義する
newではPhilosopherのインスタンスを返す
- rubyと同様、最後に評価した値が返り値となる
- new()という名前に縛りはないが、構造体からインスタンスを生成する際に慣例的に用いられる事が多い
- 可変長配列にはVec<T>を用いる
- Rustではメソッドは明示的なselfパラメータを取る
    - selfパラメータを取らないものは関連関数 ( 上のnewメソッドは関連関数 )
- Mutex: 並行処理を制御するための機構
    - 同時アクセスできるスレッドを単一にする
    - 今回の例だと各フォークにアクセスできるのは一人のみのためMutexを用いる
- Arc = アトミック参照カウント
    - 各スレッドからリソースを共有するために必要となる
    - 共有するときは参照カウントを増やし、各スレッドの終了時にはカウントを減らす　
    
# 2.3 Rust Inside Other Languages
- 高級言語の実行速度の遅さを補うためによくCで書いた実装を他の言語から呼び出して利用することがある
    - この技術はForeign Function Interface (FFI) と呼ばれる
## The Problem
- オブジェクト指向なプログラミング言語はGCを利用している
    - それで最適化されることもあるが、静的にメモリをアロケートしたい場合がある
- 多くの言語はGIL(Global Interpreter Lock) を持っている
    - これは並行処理に制限を与えている
## FFI
- fn の前に pub とつければモジュールの外から呼び出しが可能になる
- extern はCから呼び出す際に必要な枕詞になる
    
# 3-1 変数と可変性
- constキーワードで定数を宣言すれば、mutキーワードが使えず常に不変な値を持つ
    - 定数の命名規則は、全てが大文字でアンダースコアで単語区切りにする
- let で繰り返し宣言することをシャドーイング(前に宣言した変数を覆い隠している) という
```rust
let x = 5;
let x = 6; //これは許容される
x = 7 //これは許容されない
let x = "hoge" //再宣言なので違う型でもok( mut キーワードだとこれはできない )
```
# 3-2 データ型
## スカラー型
### 整数型
- i8なら符号付き8bit整数型
- u8なら符号なし8bit整数型
    - 16, 32, 64まで
- isize, usizeはプログラムが動作するコンピュータアーキテクチャに依存する
### 浮動小数点型
- f32 or f64
### 文字型
- RustではUnicodeに対応している
### 複合型
### タプル
```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
let (x , y, z) = tup; // x=500, y=6.4, z=1 が代入される
// tup.0, tup.1, tup.2 としても参照可
```
- パターンマッチングで抽出できるのが特徴
### 配列型
- Rustでは配列の大きさを返ることができない
    - 可変長配列はベクタで扱う
    
# 3-3 関数
- エントリポイントはmain関数
- 関数本体は文と式を含む
    - 文: 値を返さない命令
    - 式: 結果値に評価される命令
- `let x = 6;` は文
- 文を代入することはできない
    - `x = y = 6` はできないということ
- 文末にセミコロンをつけると、Rustコンパイラは文として扱うため、値を返さなくなるので注意
## 返り値
```rust
fn one() -> i32 { 1 }
```
- `-> 型` で返り値の型を明示的に宣言する
    - return も使えるが、多くの場合最後の式を暗黙的にreturnする形で記述されることが多い
    - 関数は式なので、セミコロンは付かない


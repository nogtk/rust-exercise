# 勉強したことをまとめていくよ
## 参考
[プログラミング言語Rust](https://doc.rust-jp.rs/the-rust-programming-language-ja/1.6/book/README.html)
# 2章 はじめる
## 知ったこと
- ! がついているとrustではマクロ扱いとなる
    - ついていなければ関数
    - マクロと関数の違いについては不明
- Cargoとはrustのビルドシステムでもありパッケージマネージャでもある
- Cargoはソースファイルをsrcディレクトリに存在することを要求する (!)
- Cargo.toml(Cは大文字)にCargoの設定を記述する
    - TOML: Tom's Obvious, Minimal Language
    - Cargoの設定フォーマットとして使われる
- `cargo build` でプロジェクトをビルドし、`cargo run`でプロジェクトを実行する
- `cargo run` では変更点の差分のみをコンパイルして実行してくれる
    - Makefileみたいな
- `cargo new`ってやるとtomlファイルとsrc配下にソースファイルが配置されたプロジェクトを生成してくれる
# 3.1章 数当てゲーム
- Rustが自動的にデフォルトで読み込むものはプレリュードと呼ばれ、それ以外はuseしないといけない
    - 標準入出力とやり取りするインターフェースが必要なら`use std::io;` する必要がある
    - プレリュード: おしゃれ。
```rust
let foo = bar;
```
- fooという束縛を作り、それをbarに束縛する、ということを表現している
    - 他の多くの言語では「変数」と呼ばれるもの。Rustでは束縛変数という
- Rustではletで宣言した束縛はデフォルトでイミュータブル。
    - ミュータブルな束縛を定義するためにmutを使う ( Ex. let mut foo = bar )

```rust
String::new()
```
- String型のインスタンスを生成しているわけではない
- ::new()は特定の型の「関連関数」(ここはよくわかってない)
    - スタティックメソッド、なんて名前で呼ばれているらしい
```rust
io::stdin().read_line(&mut guess).expect("hoge");
```
- io::stdin()は標準入出力をハンドルする
- guessという参照もデフォルトではイミュータブルなので、&mutをつけてミュータブルとして参照している
    - read_lineで取得したユーザの入力文字列を取得し、guessに代入するためにはミュータブルである必要がある

```rust
println!("hoge {}", hoge);
```
- {}はプレースホルダ
    - 複数の変数を入れたいなら「{}」も複数になる
    
 - Rustコードのパッケージは「クレート」と呼ばれる
    - Cargoプロジェクトで管理をしているなら、Cargo.tomlの[dependency]欄にクレートを記述することで依存関係を考慮してパッケージのダウンロードをしてくれる
    
- クレートはファイル内でextern use として指定することでインクルードする
- インクルードしたメソッドは、トレイトと呼ばれる空間で定義されているので、トレイトをスコープ内に取り込む必要がある ( Ex. rand::Rng)

- 値の大小を比較するときにはOrderingを使う
    - OrderingはenumでLess, Equal, Greaterという3つのバリアントを保持する

- Rustは型推論を持っているため、束縛される対象がString::new()とあれば、コンパイラはString型である、と理解をしてくれる
    - 数値に関しては、i32やu32,f64など、様々な型が用意されている
    - 指定がなければRustはデフォルトでi32として解釈する
    - 数値と文字列を単に比較しようとするとコンパイラはエラーを吐く
 
 - Rustでは同じ変数を再定義することができる( シャドーイング )
    - 型の変換時などに用いれられる
    
- matchがif文のような役割を果たしている
    - 返り値のenumに対して等しいか、大きいか小さいかなどを判定して、それに対するアクションを定義している

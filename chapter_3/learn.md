# 3-1 変数と可変性
- constキーワードで定数を宣言すれば、mutキーワードが使えず常に不変な値を持つ
    - 定数の命名規則は、全てが大文字でアンダースコアで単語区切りにする
- let で繰り返し宣言することをシャドーイング(前に宣言した変数を覆い隠している) という
```rust
let x = 5;
let x = 6; //これは許容される
x = 7 //これは許容されない
let x = "hoge" //再宣言なので違う型でもok( mut キーワードだとこれはできない )
```
# 3-2 データ型
## スカラー型
### 整数型
- i8なら符号付き8bit整数型
- u8なら符号なし8bit整数型
    - 16, 32, 64まで
- isize, usizeはプログラムが動作するコンピュータアーキテクチャに依存する
### 浮動小数点型
- f32 or f64
### 文字型
- RustではUnicodeに対応している
### 複合型
### タプル
```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
let (x , y, z) = tup; // x=500, y=6.4, z=1 が代入される
// tup.0, tup.1, tup.2 としても参照可
```
- パターンマッチングで抽出できるのが特徴
### 配列型
- Rustでは配列の大きさを返ることができない
    - 可変長配列はベクタで扱う
    
# 3-3 関数
- エントリポイントはmain関数
- 関数本体は文と式を含む
    - 文: 値を返さない命令
    - 式: 結果値に評価される命令
- `let x = 6;` は文
- 文を代入することはできない
    - `x = y = 6` はできないということ
- 文末にセミコロンをつけると、Rustコンパイラは文として扱うため、値を返さなくなるので注意
## 返り値
```rust
fn one() -> i32 { 1 }
```
- `-> 型` で返り値の型を明示的に宣言する
    - return も使えるが、多くの場合最後の式を暗黙的にreturnする形で記述されることが多い
    - 関数は式なので、セミコロンは付かない
# 3-4 コメント
特に書くことなし

#3-5 制御フロー
- ifの条件式としてboolのみが期待されている
- ifは式なのでletの右辺に持ってくることができる
### 繰り返し
- loop, for, whileがある
- loopは無限ループ
    - breakキーワードでループから抜けることができる
- whileはとく言うことなし
- forもiterを使うくらいは言うことなし

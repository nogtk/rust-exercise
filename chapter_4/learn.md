# 4-1 所有権とは
- Rustでは値がスタックに載るかヒープに載るかで、異なった影響を及ぼす場合がある
- スタックはLIFOの特徴があり、データの取り出しが高速だが、固定のメモリセグメントをアロケートしなければならない
- 動的にメモリの値が変わる値についてはヒープに確保される
- ヒープへのデータアクセスはスタックと比較して低速
- Rustの所有権はこのヒープに載っているデータを管理するための仕組み
## 所有権規則
- Rustの各値は所有者と呼ばれる変数と対応関係にある
- どんなときも所有者はひとり
- 所有者がスコープから外れると、値は破棄される
## String型
- 文字列をハードコードした「文字列リテラル」は静的な値なのでスタックで管理される
- 文字列を動的な値として処理したい場合がString型の文字列を定義する
    - メモリを動的に取れる、つまり可変であるということ
## メモリの確保
- GCは使用されていないメモリ領域を検知して片付ける
- GCがないならallocate -> freeをプログラマが制御してやらないといけない
- RustではGCがない代わりにメモリを所有している変数がスコープを抜けたタイミングでOSにメモリを返している
    - dropという関数が暗黙的に呼ばれている
## ムーブ
```rust
let x = 5;
let y = 5;
```
- 5を変数xに束縛したのち、その値をコピーしてyにも束縛している
```rust
let s1 = String::from("hello");
let s2 = s1;
println!("{}", s1); // これはコンパイルエラーを吐く
```
- s2はs1が束縛している文字列のポインタをコピーしている
    - ポインタ情報はスタックで管理されている
    - 実データはヒープに載っている
    - ヒープ上のデータがコピーされているわけではない
- s2とs1が同じメモリ領域を参照するという状況は問題がある
    - s1とs2がスコープを抜けたタイミングでdrop関数によって同じメモリ領域が2回freeされる
    - Rustコンパイラはs2のポインタをコピーしたタイミングでs1への参照を無効化する
- Rustではこの現象をムーブという
    - コピー元のデータにアクセスできなくなるshallow copy みたいな
- ヒープ上のデータもコピーしたい場合はcloneメソッドを使う
    - deep copy
    - これは本当に`コピー`なのでコピー元の変数にも参照することができる
- 整数などの固定長のデータはcloneメソッドがなくともデータそのものもコピーしている
    - スタック上に保持されているためデータのコピーも高速に動作する

# 4-2 参照と借用
- `&`を付け加えて参照することでもとの値を参照する参照を生成できる
    - 所有権を保持するわけではないのでdropされない
- 関数の引数に参照を取ることを借用と呼ぶ
    - 借用したものを変更することはできないO
- `&mut`として可変な参照として渡せば参照する側からも変更が可能となる
    - あるスコープの中で可変な参照は一つしか持つことができない
    - 一方がある一方の参照元のデータが変わることをトレースできない
- 不変な参照をしている間は、可変な参照をすることができない
    - 不変参照をしている変数は値が変わることを予想していないから
- ダングリングポインタを防ぐ仕組みがRustコンパイラに備わっている
    - ポインタが参照している領域をfreeしようとするとエラーを吐く
    
# 4-3 スライス
- スライスとはデータ列の一部分だけを借用する仕組みを指す
- 文字列スライスを意味する型は&strと書かれる
- 文字列リテラルはバイナリの特定の位置のスライスを返す&str型
    - 関数の引数の型として`&str`を指定すれば、String型も文字列リテラルも両方扱えるようになる